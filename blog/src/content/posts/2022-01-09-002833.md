---
title: "Rubyしか書けないエンジニアから脱却するためのJavaScript Primerお勉強①"
emoji: "💻"
published: 2022-01-09T00:28:33+09:00
draft: false
description: ""
tags: ["JavaScript", "学習記録", "Ruby", "プログラミング"]
category: "プログラミング"
---
<h1>はじめに</h1>

<p>エンジニアとして就職してから1年とちょっと経ちました。</p>

<p>その間ほとんどずっとRuby on RailsでのAPI開発しかして来なかったため、そろそろ他の言語も勉強してみようと思いJavaScriptを一から勉強します！</p>

<p>ちなみに現時点でのjs知識は</p>

<ul>
<li>基本文法は何となく理解している</li>
<li>ふわふわな知識でちょこっとちょっと触れるくらい</li>
</ul>


<p>ご覧の通りちょっとした知識しかないため、まずはJavaScript Primerを全て読んでみたいと思います！</p>

<p><iframe src="https://hatenablog-parts.com/embed?url=https%3A%2F%2Fjsprimer.net%2F" title="JavaScript Primer - 迷わないための入門書 #jsprimer" class="embed-card embed-webcard" scrolling="no" frameborder="0" style="display: block; width: 100%; height: 155px; max-width: 500px; margin: 10px 0px;"></iframe><cite class="hatena-citation"><a href="https://jsprimer.net/">jsprimer.net</a></cite></p>

<p>（ネットで無料で見れるのありがたすぎる... 製作者の方々、本当にありがとうございます）</p>

<h2>第一部</h2>

<h3>変数と宣言</h3>

<p><code>const</code> は再代入不可、<code>let</code>は再代入可能、<code>var</code>は使わない</p>

<p>基本は<code>const</code>で、次に<code>let</code>を使えば良さそう</p>

<p>同じスコープ内で変数の再宣言はできないっぽい</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">let</span> a = <span class="synConstant">'a'</span>;
<span class="synComment">// undefined</span>

<span class="synIdentifier">let</span> a = <span class="synConstant">'aa'</span>;
<span class="synComment">//Uncaught SyntaxError: Identifier 'a' has already been declared</span>
</pre>


<p>分割代入はこんな感じ</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synStatement">const</span> <span class="synIdentifier">[</span>b, c<span class="synIdentifier">]</span> = <span class="synIdentifier">[</span><span class="synConstant">'b'</span>, <span class="synConstant">'c'</span><span class="synIdentifier">]</span>;
b <span class="synComment">// 'b'</span>
c <span class="synComment">// 'c'</span>

<span class="synComment">// 要素数が足りない場合はundefinedが入るっぽい</span>
<span class="synStatement">const</span> <span class="synIdentifier">[</span>e, f<span class="synIdentifier">]</span> = <span class="synIdentifier">[</span><span class="synConstant">'e'</span><span class="synIdentifier">]</span>;
e <span class="synComment">// 'e'</span>
f <span class="synComment">// undefined</span>
</pre>


<h3>値の評価と表示</h3>

<p>変数宣言は<code>undefined</code>を返す</p>

<p>Rubyだとselfの値が返ってくるのでちょっと違和感</p>

<p>そもそも変数に関数を入れれるのに『変数宣言』って呼んで良いのかは疑問</p>

<p>この辺りRubyと結構違いそうなので気をつける</p>

<h3>データ型とリテラル</h3>

<p>プリミティブ型とそれ以外のオブジェクト型</p>

<p>RubyでいうところのArrayもオブジェクト型</p>

<p>Ruby的にはクラスがメソッドを持っている感じだけど、jsではオブジェクトがプロパティを持っているという理解で合ってるのかな？</p>

<p>ここに関しては続きの章で解説があるらしいので一旦保留</p>

<h3>演算子</h3>

<p>基本的にはRubyと同じ感じ</p>

<p>ただこれでなんで2になるのかは分からない...</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">let</span> num = +<span class="synConstant">'2'</span>;

num <span class="synComment">// 2</span>
</pre>


<p>Rubyみたいにオブジェクトに対してメソッドを呼ぶみたいな考え方じゃないのかも...</p>

<p><code>===</code>は比較、<code>==</code>は暗黙的な型変換してからの比較</p>

<p>jsのfalseは</p>

<ul>
<li>false</li>
<li>undefined</li>
<li>null</li>
<li>0</li>
<li>0n</li>
<li>NaN</li>
<li>""</li>
</ul>


<p>数が多いよ...</p>

<p><code>||</code>演算子だとfalsyな値全てが<code>false</code>として扱われてしまう</p>

<p><code>??</code>演算子を使えば<code>null</code>or<code>undefined</code>のみ<code>false</code>として評価される</p>

<p>演算子系は基本的にRubyと似てるので大丈夫そう</p>

<h3>暗黙的な型変換</h3>

<p>暗黙的な型変換が行われるのは分かったけど<code>1 + true</code>が<code>2</code>になるのは衝撃すぎる</p>

<p>基本的に暗黙的な型変換に頼るような実装はやめましょうみたいな理解でいいのかな？</p>

<h3>関数と宣言</h3>

<p>仮引数が渡されなかった場合はundefinedになって、多く渡した時は無視される</p>

<p>下の例だとnum2がundefinedになって<code>num1 * num2</code>の結果がNaNになる</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synStatement">const</span> multiplication = (num1, num2) =&gt; <span class="synIdentifier">{</span>
    <span class="synStatement">return</span> num1 * num2;
end

multiplication(2,3) <span class="synComment">// =&gt; 6</span>
multiplication(2) <span class="synComment">// =&gt; NaN</span>
multiplication(2,3,4)<span class="synComment">// =&gt; 6</span>
</pre>


<p>Rubyと違ってエラーにならないのか〜</p>

<p>Rubyでいう可変長引数はこんな感じ</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">function</span> fn(...args) <span class="synIdentifier">{</span>
    <span class="synStatement">return</span> args;
<span class="synIdentifier">}</span>

fn(1,2,3,4,5) <span class="synComment">// =&gt; [1, 2, 3, 4, 5]</span>

<span class="synComment">////////////////</span>

<span class="synIdentifier">function</span> fn(num1, num2) <span class="synIdentifier">{</span>
 <span class="synStatement">return</span> num1 * num2;
<span class="synIdentifier">}</span>

fn(...<span class="synIdentifier">[</span>2,3<span class="synIdentifier">]</span>) <span class="synComment">// =&gt; 6</span>
</pre>


<p><code>argments</code>という関数の中でのみ参照できる特殊な変数がある</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">function</span> fn() <span class="synIdentifier">{</span>
    console.log(<span class="synIdentifier">arguments</span>);
<span class="synIdentifier">}</span>

fn(1, 2, 3) <span class="synComment">// =&gt; [Arguments] { '0': 1, '1': 2 }</span>
</pre>


<p>Arrayっぽいけど実際はObjectの形で値が入ってるため、インデックスを使って値は取れるけどArrayのメソッドは使えないみたい</p>

<p>ただそもそもArrayもObject型なのに、Arrayのみで使えるメソッドが定義されてるってどういうこと？？</p>

<p>この辺りからちょっと理解が難しい...</p>

<p>jsの関数は第一級関数と言って変数に代入できる</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synIdentifier">function</span> <span class="synStatement">double</span> (num) <span class="synIdentifier">{</span>
    <span class="synStatement">return</span> num * 2;
 <span class="synIdentifier">}</span>

<span class="synStatement">const</span> fn_1 = <span class="synStatement">double</span>; <span class="synComment">// ()付きで渡してないので関数が変数に代入される</span>
<span class="synStatement">const</span> fn_2 = <span class="synStatement">double</span>(5); <span class="synComment">// ()付きで渡してるので関数の戻り値が代入される</span>
</pre>


<p>Arrow Functionの書き方で関数式を短く書ける</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synStatement">const</span> fnA = (x) =&gt; <span class="synIdentifier">{</span> <span class="synStatement">return</span> x; <span class="synIdentifier">}</span>;
<span class="synStatement">const</span> fnB = x =&gt; <span class="synIdentifier">{</span> <span class="synStatement">return</span> x; <span class="synIdentifier">}</span>; <span class="synComment">// 仮引数がひとつなら()を省略できる</span>
<span class="synStatement">const</span> fnC = x =&gt; x; <span class="synComment">// 一行のみの場合はブロックとreturnを省略できる</span>

x =&gt; x; <span class="synComment">// 無名関数だとこんな感じで書ける</span>
</pre>


<p>引数として渡される関数の事をコールバック関数というのは何となく知ってた</p>

<p>オブジェクトのプロパティである関数をメソッドと呼ぶらしい</p>

<p>第一級関数で関数を値として扱えるからオブジェクトの値に関数を定義できるってことかな？</p>

<p>ここが全くRubyと違うのでびっくりした</p>

<pre class="code lang-javascript" data-lang="javascript" data-unlink><span class="synStatement">const</span> obj = <span class="synIdentifier">{</span>
    method: num =&gt; num
<span class="synIdentifier">}</span>;

obj.method(10) <span class="synComment">// =&gt; 10</span>

<span class="synComment">// こういうい書き方もできる（推奨らしい）</span>
<span class="synStatement">const</span> obj = <span class="synIdentifier">{</span>
    method(num) <span class="synIdentifier">{</span>
        <span class="synStatement">return</span> num;
    <span class="synIdentifier">}</span>
<span class="synIdentifier">}</span>
</pre>


<p><code>obj.hoge</code>でオブジェクトに新しくプロパティを追加できる</p>

<h1>感想</h1>

<p>やっぱりRubyとは全然違うなぁという感想</p>

<p>色々触ってみないと本質的なところが分からないと思うので、とりあえずJavaScript Primer終えたら違う本買ってみようと思います！</p>

<p>続きは後日</p>

-----
